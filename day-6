正则表达式

	就是一个处理字符串的强大工具，有自己独特的语法结构，实现字符串的检索，替换，匹配验证


	1.re库

	    1.match（）
		传入要匹配的字符串以及正则表达式，就可以检测这个正则表达式是否匹配字符串

		1.用法：import re
			content = "i'm learning zheng ze biao da shi"
			print(len(content))
			result = re.match('^i\S\w\s\w{5}',content)
			print(result.group())---输出匹配到的内容
			print(result.span())---输出匹配的范围


		2.匹配目标：
			在正则表达式中用（）括起来，然后调用group（1）来调用第一个（）括起来的内容，后面的依次用group（2），group（3）来匹配


		3.通用匹配：
			一般在特定的内容时候，不需要一个一个的匹配每一个字符，可以用.*（点星）匹配任意内容，再加上结尾的特定字符即可。
			result = re.match('^i.*ze$',content)

		贪婪与非贪婪。
		例子：
			content = "hello 123456789 world hahahhh"
			result = re.match('^hello.*(/d+).*hahahhh',content)
			result2 = re.match(^hello.*?(/d+).*hahahhh',content)
			print(result.group(1))
			print(result2.group(1))
			你会发现第一行结果竟然只一个9，
			而第二行结果是123456789.

	原因：	就是.*（点星）这个匹配符是 贪婪的 尽可能多 的去匹配字符
		而.*?（点星问号）是非贪婪的 尽可能少 的去匹配字符

	总结：	尽量把.*?放在字符串的中间
		而需要注意的是，如果把.*?放在末尾，就是可能匹配不到任何内容		

		4.修饰符
			正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。

		content ='''hello 1233213 world
			is a text.
			```
		result = re.match(^hello.*?(/+d).*?text$',content)----会报错
	因为\和.都不能匹配换行符，当遇到文本中有换行符的时候，就有可能要出错。

		此时只要加上一个修饰符re.S作为第三个参数，即可。这个修饰符的意思就是是.可以匹配包括换行符也在内的所有字符。

	所有的修饰符：	re.I:使匹配对大小写不敏感（网页匹配中常用）
			re.L:做本地化识别匹配
			re.M:多行匹配
			re.S：使.匹配包括换行符在那的所有字符（网页匹配中常用）
			re.U：根据Unicode字符集解析字符。这个标志影响\w、\W、\b、\B
			re.X：该标志通过给予你更灵活的格式以便你讲正则表达式写的更易于理解

		5.转义字符
			前面加个反斜杠\，对于特殊字符
	2.search()
		因为match是从头开始匹配，所以一旦开头不匹配就会直接整个匹配都失败
		因而match（）方法做匹配不太方便，它更适合来检测某个字符串是否符合某个正则表达式的规则。
		而search（），它在匹配时会扫描整个字符串，然后只返回第一个匹配的结果。也就是说正则表达式可以是字符串的一部分。
		###注意只返回一个匹配结果哦！
		

	3.findall（）
		比search要大方，它返回的是所有的匹配的字符串。

	4.sub（）
		除了用正则表达式提取信息以外，有时候还可以用它来修改文本。比如要把一串文本中的所有数字都去掉。就可以借助sub（）方法
		import re
		content = ‘21ndasd2139ad12jds'
		content - 're.sub('\d+’,'',content)
		print(content)

		>>>ndasdadjds

		第一个参数是正则表达式，第二个参数是要替换成的字符串（删除就赋值空）第三个参数就是原字符串
		##正则表达式可以用|来做并列关系，即re.sub('a|d|s','',content)
						>>>nj

	5.compile()------就是封装正则表达式
		这是一个将正则表达式编译成正则表达式对象的一个方法。方便复用

		用法：pattern = re,compile('\d{2}:\d{2}')
			pattern 就是一个正则表达式对象
		
